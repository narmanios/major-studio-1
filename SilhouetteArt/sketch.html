<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Silhouette Morph — Auto Fit & Loop</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <!-- GSAP + MorphSVG -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/MorphSVGPlugin.min.js"></script> -->

    <!-- <script defer src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.0/gsap.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.0/MorphSVGPlugin.min.js"></script> -->

    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        :root {
            color-scheme: light;
        }

        body {
            margin: 0;
            height: 100vh;
            display: grid;
            place-items: center;
            background: none;
            font-family: system-ui, sans-serif;
        }

        svg {
            width: min(80vmin, 900px);
            height: auto;
            display: block;
        }

        .hint {
            position: fixed;
            bottom: 10px;
            left: 12px;
            opacity: .7;
            font-size: 12px;
        }
    </style>

</head>

<body>


    <!-- Big, safe viewBox; we’ll fit both shapes into this via a <g> transform -->
    <svg id="stage" viewBox="0 0 1200 1200" preserveAspectRatio="xMidYMid meet" aria-label="Morphing silhouettes">
        <g id="fitGroup">
            <path id="shape1" fill="#000"></path>
            <path id="shape2" fill="#000" style="visibility:hidden"></path>
        </g>
    </svg>

    <div class="hint">morphing…</div>

    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13/dist/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.0/MorphSVGPlugin.min.js"></script>
    <script>
        // load and morph SVGs from the local svgs/ folder using IDs saved in localStorage ("morphSelection")
        window.addEventListener("load", async () => {
            try {
                if (!window.gsap || !window.MorphSVGPlugin) {
                    console.error("GSAP or MorphSVGPlugin not available");
                    return;
                }
                gsap.registerPlugin(MorphSVGPlugin);
                const stage = document.getElementById("stage");
                const fitGroup = document.getElementById("fitGroup");
                const p1 = document.getElementById("shape1");
                if (!stage || !fitGroup || !p1) throw new Error("Missing SVG elements");
                function svgUrlForId(id) {
                    if (!id) return null;
                    // if full path or ends with .svg leave as-is
                    if (id.includes("/") || id.toLowerCase().endsWith(".svg")) return id;
                    // otherwise load from local svgs/ folder and accept numeric or zero-padded ids
                    return `svgs/${id}.svg`;
                }

                async function getPathD(url) {
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(`Failed to fetch ${url} (${res.status})`);
                    const txt = await res.text();
                    const doc = new DOMParser().parseFromString(txt, "image/svg+xml");
                    const path = doc.querySelector("path");
                    if (!path) throw new Error(`No <path> in ${url}`);
                    return path.getAttribute("d");
                }

                function fitToViewBox() {
                    try {
                        const bb1 = p1.getBBox();
                        const refs = fitGroup.querySelectorAll(".morph-ref");
                        let minX = bb1.x, minY = bb1.y, maxX = bb1.x + bb1.width, maxY = bb1.y + bb1.height;
                        refs.forEach(r => {
                            const b = r.getBBox();
                            minX = Math.min(minX, b.x);
                            minY = Math.min(minY, b.y);
                            maxX = Math.max(maxX, b.x + b.width);
                            maxY = Math.max(maxY, b.y + b.height);
                        });
                        const bw = Math.max(1, maxX - minX);
                        const bh = Math.max(1, maxY - minY);
                        const vb = stage.viewBox.baseVal;
                        const scale = Math.min(vb.width / bw, vb.height / bh) * 0.92;
                        const tx = (vb.width - bw * scale) * 0.5 - minX * scale;
                        const ty = (vb.height - bh * scale) * 0.5 - minY * scale;
                        fitGroup.setAttribute("transform", `matrix(${scale} 0 0 ${scale} ${tx} ${ty})`);
                    } catch (e) { /* ignore early measurement errors */ }
                }
                // read selection saved by gallery
                let entries = [];
                try {
                    const raw = localStorage.getItem("morphSelection");
                    entries = raw ? JSON.parse(raw) : [];
                } catch { entries = []; }

                if (!Array.isArray(entries) || entries.length === 0) {
                    entries = ["00097", "00098"]; // fallback ids
                }

                // fetch path data for each selected id (from svgs/ folder)
                const pathDs = [];
                for (const id of entries) {
                    const url = svgUrlForId(String(id).trim());
                    if (!url) continue;
                    try {
                        const d = await getPathD(url);
                        pathDs.push(d);
                    } catch (err) {
                        console.warn("Skipping", url, err);
                    }
                }

                if (pathDs.length === 0) throw new Error("No valid SVG paths loaded");

                // remove old refs
                fitGroup.querySelectorAll(".morph-ref").forEach(n => n.remove());

                // create hidden reference paths
                const refs = pathDs.map((d, i) => {
                    const ref = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    ref.setAttribute("d", d);
                    ref.setAttribute("class", "morph-ref");
                    ref.style.visibility = "hidden";
                    fitGroup.appendChild(ref);
                    return ref;
                });

                // start with first path
                p1.setAttribute("d", pathDs[0]);

                requestAnimationFrame(() => {
                    fitToViewBox();
                    const prefersReduced = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
                    if (prefersReduced) {
                        // no animation
                        return;
                    }
                    const tl = gsap.timeline({ repeat: -1, defaults: { ease: "power1.inOut", duration: 1.4 } });
                    for (let i = 1; i < refs.length; i++) tl.to(p1, { morphSVG: refs[i] });
                    if (refs.length > 1) tl.to(p1, { morphSVG: refs[0] }); // loop back
                });

                let rTO;
                window.addEventListener("resize", () => {
                    clearTimeout(rTO);
                    rTO = setTimeout(() => requestAnimationFrame(fitToViewBox), 150);
                });
            } catch (err) {
                console.error(err);
                const hint = document.querySelector(".hint");
                if (hint) hint.textContent = "Error: " + err.message;
            }
        });
    </script>
</body>

</html>